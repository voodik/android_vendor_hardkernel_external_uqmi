/* generated by uqmi gen-code.pl */
#include <stdio.h>
#include <string.h>
#include "qmi-message.h"

#define get_next(_size) ({ void *_buf = &tlv->data[ofs]; ofs += _size; if (ofs > cur_tlv_len) goto error_len; _buf; })
#define copy_tlv(_val, _size) \
	do { \
		unsigned int __size = _size; \
		if (__size > 0) \
			memcpy(__qmi_alloc_static(__size), _val, __size); \
	} while (0);

#define put_tlv_var(_type, _val, _size) \
	do { \
		_type __var = _val; \
		copy_tlv(&__var, _size); \
	} while(0)

int qmi_set_nas_reset_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0000);

	return 0;
}

int qmi_parse_nas_reset_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_nas_abort_request(struct qmi_msg *msg, struct qmi_nas_abort_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0001);

	if (req->set.transaction_id) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.transaction_id), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_nas_abort_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_nas_set_event_report_request(struct qmi_msg *msg, struct qmi_nas_set_event_report_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0002);

	if (req->set.signal_strength_indicator) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.signal_strength_indicator.report, 1);
		put_tlv_var(uint8_t, req->data.signal_strength_indicator.thresholds_n, 1);
		for (i = 0; i < req->data.signal_strength_indicator.thresholds_n; i++) {
			put_tlv_var(uint8_t, req->data.signal_strength_indicator.thresholds[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->set.rf_band_information) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.rf_band_information, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	if (req->set.registration_reject_reason) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.registration_reject_reason, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x12, ofs, buf);
	}

	if (req->set.rssi_indicator) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.rssi_indicator.report, 1);
		put_tlv_var(uint8_t, req->data.rssi_indicator.rssi_delta, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x13, ofs, buf);
	}

	if (req->set.ecio_indicator) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.ecio_indicator.report, 1);
		put_tlv_var(uint8_t, req->data.ecio_indicator.ecio_delta, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x14, ofs, buf);
	}

	if (req->set.io_indicator) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.io_indicator.report, 1);
		put_tlv_var(uint8_t, req->data.io_indicator.io_delta, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x15, ofs, buf);
	}

	if (req->set.sinr_indicator) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.sinr_indicator.report, 1);
		put_tlv_var(uint8_t, req->data.sinr_indicator.sinr_delta, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x16, ofs, buf);
	}

	if (req->set.error_rate_indicator) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.error_rate_indicator, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x17, ofs, buf);
	}

	if (req->set.ecio_threshold) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.ecio_threshold.report, 1);
		put_tlv_var(uint8_t, req->data.ecio_threshold.thresholds_n, 1);
		for (i = 0; i < req->data.ecio_threshold.thresholds_n; i++) {
			put_tlv_var(uint16_t, cpu_to_le16(req->data.ecio_threshold.thresholds[i]), 2);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x19, ofs, buf);
	}

	if (req->set.sinr_threshold) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.sinr_threshold.report, 1);
		put_tlv_var(uint8_t, req->data.sinr_threshold.thresholds_n, 1);
		for (i = 0; i < req->data.sinr_threshold.thresholds_n; i++) {
			put_tlv_var(uint8_t, req->data.sinr_threshold.thresholds[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1A, ofs, buf);
	}

	if (req->set.lte_snr_delta) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.lte_snr_delta.report, 1);
		put_tlv_var(uint8_t, req->data.lte_snr_delta.snr_delta, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1B, ofs, buf);
	}

	if (req->set.lte_rsrp_delta) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.lte_rsrp_delta.report, 1);
		put_tlv_var(uint8_t, req->data.lte_rsrp_delta.rsrp_delta, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1C, ofs, buf);
	}

	return 0;
}

int qmi_parse_nas_set_event_report_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_nas_register_indications_request(struct qmi_msg *msg, struct qmi_nas_register_indications_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0003);

	if (req->set.system_selection_preference) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.system_selection_preference, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->set.ddtm_events) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.ddtm_events, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x12, ofs, buf);
	}

	if (req->set.serving_system_events) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.serving_system_events, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x13, ofs, buf);
	}

	if (req->set.dual_standby_preference) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.dual_standby_preference, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x14, ofs, buf);
	}

	if (req->set.subscription_info) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.subscription_info, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x15, ofs, buf);
	}

	if (req->set.network_time) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.network_time, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x17, ofs, buf);
	}

	if (req->set.system_info) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.system_info, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x18, ofs, buf);
	}

	if (req->set.signal_info) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.signal_info, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x19, ofs, buf);
	}

	if (req->set.error_rate) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.error_rate, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1A, ofs, buf);
	}

	if (req->set.hdr_new_uati_assigned) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.hdr_new_uati_assigned, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1B, ofs, buf);
	}

	if (req->set.hdr_session_closed) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.hdr_session_closed, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1C, ofs, buf);
	}

	if (req->set.managed_roaming) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.managed_roaming, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1D, ofs, buf);
	}

	if (req->set.current_plmn_name) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.current_plmn_name, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1E, ofs, buf);
	}

	if (req->set.embms_status) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.embms_status, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1F, ofs, buf);
	}

	if (req->set.rf_band_information) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.rf_band_information, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x20, ofs, buf);
	}

	return 0;
}

int qmi_parse_nas_register_indications_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_nas_get_signal_strength_request(struct qmi_msg *msg, struct qmi_nas_get_signal_strength_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0020);

	if (req->set.request_mask) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.request_mask), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	return 0;
}

int qmi_parse_nas_get_signal_strength_response(struct qmi_msg *msg, struct qmi_nas_get_signal_strength_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.signal_strength = 1;
			res->data.signal_strength.strength = *(int8_t *) get_next(1);
			res->data.signal_strength.radio_interface = *(int8_t *) get_next(1);
			break;

		case 0x10:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.strength_list = __qmi_alloc_static(i * sizeof(res->data.strength_list[0]));
			while(i-- > 0) {
				res->data.strength_list[res->data.strength_list_n].strength = *(int8_t *) get_next(1);
				res->data.strength_list[res->data.strength_list_n].radio_interface = *(int8_t *) get_next(1);
				res->data.strength_list_n++;
			}

			break;

		case 0x11:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.rssi_list = __qmi_alloc_static(i * sizeof(res->data.rssi_list[0]));
			while(i-- > 0) {
				res->data.rssi_list[res->data.rssi_list_n].rssi = *(uint8_t *) get_next(1);
				res->data.rssi_list[res->data.rssi_list_n].radio_interface = *(int8_t *) get_next(1);
				res->data.rssi_list_n++;
			}

			break;

		case 0x12:
			if (found[0] & (1 << 4))
				break;

			found[0] |= (1 << 4);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.ecio_list = __qmi_alloc_static(i * sizeof(res->data.ecio_list[0]));
			while(i-- > 0) {
				res->data.ecio_list[res->data.ecio_list_n].ecio = *(int8_t *) get_next(1);
				res->data.ecio_list[res->data.ecio_list_n].radio_interface = *(int8_t *) get_next(1);
				res->data.ecio_list_n++;
			}

			break;

		case 0x13:
			if (found[0] & (1 << 5))
				break;

			found[0] |= (1 << 5);
			qmi_set(res, io, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x14:
			if (found[0] & (1 << 6))
				break;

			found[0] |= (1 << 6);
			qmi_set(res, sinr, *(uint8_t *) get_next(1));
			break;

		case 0x15:
			if (found[0] & (1 << 7))
				break;

			found[0] |= (1 << 7);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.error_rate_list = __qmi_alloc_static(i * sizeof(res->data.error_rate_list[0]));
			while(i-- > 0) {
				res->data.error_rate_list[res->data.error_rate_list_n].rate = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.error_rate_list[res->data.error_rate_list_n].radio_interface = *(int8_t *) get_next(1);
				res->data.error_rate_list_n++;
			}

			break;

		case 0x16:
			if (found[0] & (1 << 8))
				break;

			found[0] |= (1 << 8);
			res->set.rsrq = 1;
			res->data.rsrq.rsrq = *(int8_t *) get_next(1);
			res->data.rsrq.radio_interface = *(int8_t *) get_next(1);
			break;

		case 0x17:
			if (found[0] & (1 << 9))
				break;

			found[0] |= (1 << 9);
			qmi_set(res, lte_snr, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		case 0x18:
			if (found[0] & (1 << 10))
				break;

			found[0] |= (1 << 10);
			qmi_set(res, lte_rsrp, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_nas_network_scan_request(struct qmi_msg *msg, struct qmi_nas_network_scan_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0021);

	if (req->set.network_type) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.network_type, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	return 0;
}

int qmi_parse_nas_network_scan_response(struct qmi_msg *msg, struct qmi_nas_network_scan_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.network_information = __qmi_alloc_static(i * sizeof(res->data.network_information[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.network_information[res->data.network_information_n].mcc = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.network_information[res->data.network_information_n].mnc = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.network_information[res->data.network_information_n].network_status = *(uint8_t *) get_next(1);
				ii = *(uint8_t *) get_next(1);
				res->data.network_information[res->data.network_information_n].description = __qmi_copy_string(get_next(ii), ii);
				res->data.network_information_n++;
			}

			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.radio_access_technology = __qmi_alloc_static(i * sizeof(res->data.radio_access_technology[0]));
			while(i-- > 0) {
				res->data.radio_access_technology[res->data.radio_access_technology_n].mcc = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.radio_access_technology[res->data.radio_access_technology_n].mnc = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.radio_access_technology[res->data.radio_access_technology_n].radio_interface = *(int8_t *) get_next(1);
				res->data.radio_access_technology_n++;
			}

			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.mnc_pcs_digit_include_status = __qmi_alloc_static(i * sizeof(res->data.mnc_pcs_digit_include_status[0]));
			while(i-- > 0) {
				res->data.mnc_pcs_digit_include_status[res->data.mnc_pcs_digit_include_status_n].mcc = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.mnc_pcs_digit_include_status[res->data.mnc_pcs_digit_include_status_n].mnc = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.mnc_pcs_digit_include_status[res->data.mnc_pcs_digit_include_status_n].includes_pcs_digit = *(uint8_t *) get_next(1);
				res->data.mnc_pcs_digit_include_status_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_nas_initiate_network_register_request(struct qmi_msg *msg, struct qmi_nas_initiate_network_register_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0022);

	if (req->set.action) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.action, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.manual_registration_info_3gpp) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.manual_registration_info_3gpp.mcc), 2);
		put_tlv_var(uint16_t, cpu_to_le16(req->data.manual_registration_info_3gpp.mnc), 2);
		put_tlv_var(uint8_t, req->data.manual_registration_info_3gpp.radio_interface, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->set.change_duration) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.change_duration, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	if (req->set.mnc_pcs_digit_include_status) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.mnc_pcs_digit_include_status, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x12, ofs, buf);
	}

	return 0;
}

int qmi_parse_nas_initiate_network_register_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_nas_get_serving_system_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0024);

	return 0;
}

int qmi_parse_nas_get_serving_system_response(struct qmi_msg *msg, struct qmi_nas_get_serving_system_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.serving_system = 1;
			res->data.serving_system.registration_state = *(uint8_t *) get_next(1);
			res->data.serving_system.cs_attach_state = *(uint8_t *) get_next(1);
			res->data.serving_system.ps_attach_state = *(uint8_t *) get_next(1);
			res->data.serving_system.selected_network = *(uint8_t *) get_next(1);
			i = *(uint8_t *) get_next(1);
			res->data.serving_system.radio_interfaces = __qmi_alloc_static(i * sizeof(res->data.serving_system.radio_interfaces[0]));
			while(i-- > 0) {
				res->data.serving_system.radio_interfaces[res->data.serving_system.radio_interfaces_n] = *(int8_t *) get_next(1);
				res->data.serving_system.radio_interfaces_n++;
			}
			break;

		case 0x10:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, roaming_indicator, *(uint8_t *) get_next(1));
			break;

		case 0x11:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			i = *(uint8_t *) get_next(1);
			res->data.data_service_capability = __qmi_alloc_static(i * sizeof(res->data.data_service_capability[0]));
			while(i-- > 0) {
				res->data.data_service_capability[res->data.data_service_capability_n] = *(uint8_t *) get_next(1);
				res->data.data_service_capability_n++;
			}

			break;

		case 0x12:
			if (found[0] & (1 << 4))
				break;

			found[0] |= (1 << 4);
			res->set.current_plmn = 1;
			res->data.current_plmn.mcc = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.current_plmn.mnc = le16_to_cpu(*(uint16_t *) get_next(2));
			i = *(uint8_t *) get_next(1);
			res->data.current_plmn.description = __qmi_copy_string(get_next(i), i);
			break;

		case 0x13:
			if (found[0] & (1 << 5))
				break;

			found[0] |= (1 << 5);
			res->set.cdma_system_id = 1;
			res->data.cdma_system_id.sid = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.cdma_system_id.nid = le16_to_cpu(*(uint16_t *) get_next(2));
			break;

		case 0x14:
			if (found[0] & (1 << 6))
				break;

			found[0] |= (1 << 6);
			res->set.cdma_base_station_info = 1;
			res->data.cdma_base_station_info.base_station_id = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.cdma_base_station_info.base_station_latitude = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.cdma_base_station_info.base_station_longitude = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		case 0x15:
			if (found[0] & (1 << 7))
				break;

			found[0] |= (1 << 7);
			i = *(uint8_t *) get_next(1);
			res->data.roaming_indicator_list = __qmi_alloc_static(i * sizeof(res->data.roaming_indicator_list[0]));
			while(i-- > 0) {
				res->data.roaming_indicator_list[res->data.roaming_indicator_list_n].radio_interface = *(uint8_t *) get_next(1);
				res->data.roaming_indicator_list[res->data.roaming_indicator_list_n].roaming_indicator = *(uint8_t *) get_next(1);
				res->data.roaming_indicator_list_n++;
			}

			break;

		case 0x16:
			if (found[0] & (1 << 8))
				break;

			found[0] |= (1 << 8);
			qmi_set(res, default_roaming_indicator, *(uint8_t *) get_next(1));
			break;

		case 0x17:
			if (found[0] & (1 << 9))
				break;

			found[0] |= (1 << 9);
			res->set.time_zone_3gpp2 = 1;
			res->data.time_zone_3gpp2.leap_seconds = *(uint8_t *) get_next(1);
			res->data.time_zone_3gpp2.local_time_offset = *(int8_t *) get_next(1);
			res->data.time_zone_3gpp2.daylight_saving_time = *(uint8_t *) get_next(1);
			break;

		case 0x18:
			if (found[0] & (1 << 10))
				break;

			found[0] |= (1 << 10);
			qmi_set(res, cdma_p_rev, *(uint8_t *) get_next(1));
			break;

		case 0x1A:
			if (found[0] & (1 << 11))
				break;

			found[0] |= (1 << 11);
			qmi_set(res, time_zone_3gpp, *(int8_t *) get_next(1));
			break;

		case 0x1B:
			if (found[0] & (1 << 12))
				break;

			found[0] |= (1 << 12);
			qmi_set(res, daylight_saving_time_adjustment_3gpp, *(uint8_t *) get_next(1));
			break;

		case 0x1C:
			if (found[0] & (1 << 13))
				break;

			found[0] |= (1 << 13);
			qmi_set(res, lac_3gpp, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		case 0x1D:
			if (found[0] & (1 << 14))
				break;

			found[0] |= (1 << 14);
			qmi_set(res, cid_3gpp, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x1E:
			if (found[0] & (1 << 15))
				break;

			found[0] |= (1 << 15);
			qmi_set(res, concurrent_service_info_3gpp2, *(uint8_t *) get_next(1));
			break;

		case 0x1F:
			if (found[0] & (1 << 16))
				break;

			found[0] |= (1 << 16);
			qmi_set(res, prl_indicator_3gpp2, *(uint8_t *) get_next(1));
			break;

		case 0x20:
			if (found[0] & (1 << 17))
				break;

			found[0] |= (1 << 17);
			qmi_set(res, dtm_support, *(uint8_t *) get_next(1));
			break;

		case 0x21:
			if (found[0] & (1 << 18))
				break;

			found[0] |= (1 << 18);
			res->set.detailed_service_status = 1;
			res->data.detailed_service_status.status = *(uint8_t *) get_next(1);
			res->data.detailed_service_status.capability = *(uint8_t *) get_next(1);
			res->data.detailed_service_status.hdr_status = *(uint8_t *) get_next(1);
			res->data.detailed_service_status.hdr_hybrid = *(uint8_t *) get_next(1);
			res->data.detailed_service_status.forbidden = *(uint8_t *) get_next(1);
			break;

		case 0x22:
			if (found[0] & (1 << 19))
				break;

			found[0] |= (1 << 19);
			res->set.cdma_system_info = 1;
			res->data.cdma_system_info.mcc = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.cdma_system_info.imsi_11_12 = *(uint8_t *) get_next(1);
			break;

		case 0x23:
			if (found[0] & (1 << 20))
				break;

			found[0] |= (1 << 20);
			qmi_set(res, hdr_personality, *(uint8_t *) get_next(1));
			break;

		case 0x24:
			if (found[0] & (1 << 21))
				break;

			found[0] |= (1 << 21);
			qmi_set(res, lte_tac, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		case 0x25:
			if (found[0] & (1 << 22))
				break;

			found[0] |= (1 << 22);
			res->set.call_barring_status = 1;
			res->data.call_barring_status.cs_status = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.call_barring_status.ps_status = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		case 0x26:
			if (found[0] & (1 << 23))
				break;

			found[0] |= (1 << 23);
			qmi_set(res, umts_primary_scrambling_code, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		case 0x27:
			if (found[0] & (1 << 24))
				break;

			found[0] |= (1 << 24);
			res->set.mnc_pcs_digit_include_status = 1;
			res->data.mnc_pcs_digit_include_status.mcc = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.mnc_pcs_digit_include_status.mnc = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.mnc_pcs_digit_include_status.includes_pcs_digit = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_nas_get_home_network_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0025);

	return 0;
}

int qmi_parse_nas_get_home_network_response(struct qmi_msg *msg, struct qmi_nas_get_home_network_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.home_network = 1;
			res->data.home_network.mcc = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.home_network.mnc = le16_to_cpu(*(uint16_t *) get_next(2));
			i = *(uint8_t *) get_next(1);
			res->data.home_network.description = __qmi_copy_string(get_next(i), i);
			break;

		case 0x10:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			res->set.home_system_id = 1;
			res->data.home_system_id.sid = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.home_system_id.nid = le16_to_cpu(*(uint16_t *) get_next(2));
			break;

		case 0x11:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			res->set.home_network_3gpp2 = 1;
			res->data.home_network_3gpp2.mcc = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.home_network_3gpp2.mnc = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.home_network_3gpp2.display_description = *(uint8_t *) get_next(1);
			res->data.home_network_3gpp2.description_encoding = *(uint8_t *) get_next(1);
			i = *(uint8_t *) get_next(1);
			res->data.home_network_3gpp2.description = __qmi_copy_string(get_next(i), i);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_nas_set_technology_preference_request(struct qmi_msg *msg, struct qmi_nas_set_technology_preference_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x002A);

	if (req->set.current) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.current.technology_preference), 2);
		put_tlv_var(uint8_t, req->data.current.technology_preference_duration, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_nas_set_technology_preference_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_nas_get_technology_preference_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x002B);

	return 0;
}

int qmi_parse_nas_get_technology_preference_response(struct qmi_msg *msg, struct qmi_nas_get_technology_preference_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.active = 1;
			res->data.active.technology_preference = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.active.technology_preference_duration = *(uint8_t *) get_next(1);
			break;

		case 0x10:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, persistent, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_nas_get_rf_band_information_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0031);

	return 0;
}

int qmi_parse_nas_get_rf_band_information_response(struct qmi_msg *msg, struct qmi_nas_get_rf_band_information_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x11:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = *(uint8_t *) get_next(1);
			res->data.list = __qmi_alloc_static(i * sizeof(res->data.list[0]));
			while(i-- > 0) {
				res->data.list[res->data.list_n].radio_interface = *(int8_t *) get_next(1);
				res->data.list[res->data.list_n].active_band_class = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.list[res->data.list_n].active_channel = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.list_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_nas_set_system_selection_preference_request(struct qmi_msg *msg, struct qmi_nas_set_system_selection_preference_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0033);

	if (req->set.emergency_mode) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.emergency_mode, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->set.mode_preference) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.mode_preference), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	if (req->set.band_preference) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint64_t, cpu_to_le64(req->data.band_preference), 8);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x12, ofs, buf);
	}

	if (req->set.cdma_prl_preference) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.cdma_prl_preference), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x13, ofs, buf);
	}

	if (req->set.roaming_preference) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.roaming_preference), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x14, ofs, buf);
	}

	if (req->set.lte_band_preference) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint64_t, cpu_to_le64(req->data.lte_band_preference), 8);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x15, ofs, buf);
	}

	if (req->set.network_selection_preference) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.network_selection_preference.mode, 1);
		put_tlv_var(uint16_t, cpu_to_le16(req->data.network_selection_preference.mcc), 2);
		put_tlv_var(uint16_t, cpu_to_le16(req->data.network_selection_preference.mnc), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x16, ofs, buf);
	}

	if (req->set.change_duration) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.change_duration, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x17, ofs, buf);
	}

	if (req->set.service_domain_preference) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.service_domain_preference), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x18, ofs, buf);
	}

	if (req->set.gsm_wcdma_acquisition_order_preference) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.gsm_wcdma_acquisition_order_preference), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x19, ofs, buf);
	}

	if (req->set.mnc_pds_digit_include_status) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.mnc_pds_digit_include_status, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1A, ofs, buf);
	}

	if (req->set.td_scdma_band_preference) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint64_t, cpu_to_le64(req->data.td_scdma_band_preference), 8);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1D, ofs, buf);
	}

	return 0;
}

int qmi_parse_nas_set_system_selection_preference_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_nas_get_system_selection_preference_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0034);

	return 0;
}

int qmi_parse_nas_get_system_selection_preference_response(struct qmi_msg *msg, struct qmi_nas_get_system_selection_preference_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, emergency_mode, *(uint8_t *) get_next(1));
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, mode_preference, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			qmi_set(res, band_preference, le64_to_cpu(*(uint64_t *) get_next(8)));
			break;

		case 0x13:
			if (found[0] & (1 << 4))
				break;

			found[0] |= (1 << 4);
			qmi_set(res, cdma_prl_preference, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		case 0x14:
			if (found[0] & (1 << 5))
				break;

			found[0] |= (1 << 5);
			qmi_set(res, roaming_preference, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		case 0x15:
			if (found[0] & (1 << 6))
				break;

			found[0] |= (1 << 6);
			qmi_set(res, lte_band_preference, le64_to_cpu(*(uint64_t *) get_next(8)));
			break;

		case 0x16:
			if (found[0] & (1 << 7))
				break;

			found[0] |= (1 << 7);
			qmi_set(res, network_selection_preference, *(uint8_t *) get_next(1));
			break;

		case 0x18:
			if (found[0] & (1 << 8))
				break;

			found[0] |= (1 << 8);
			qmi_set(res, service_domain_preference, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x19:
			if (found[0] & (1 << 9))
				break;

			found[0] |= (1 << 9);
			qmi_set(res, gsm_wcdma_acquisition_order_preference, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x1A:
			if (found[0] & (1 << 10))
				break;

			found[0] |= (1 << 10);
			qmi_set(res, td_scdma_band_preference, le64_to_cpu(*(uint64_t *) get_next(8)));
			break;

		case 0x1B:
			if (found[0] & (1 << 11))
				break;

			found[0] |= (1 << 11);
			res->set.manual_network_selection = 1;
			res->data.manual_network_selection.mcc = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.manual_network_selection.mnc = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.manual_network_selection.includes_pcs_digit = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_nas_get_cell_location_info_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0043);

	return 0;
}

int qmi_parse_nas_get_cell_location_info_response(struct qmi_msg *msg, struct qmi_nas_get_cell_location_info_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.geran_info = 1;
			res->data.geran_info.cell_id = le32_to_cpu(*(uint32_t *) get_next(4));
			i = 3;
			res->data.geran_info.plmn = __qmi_copy_string(get_next(i), i);
			res->data.geran_info.lac = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.geran_info.geran_absolute_rf_channel_number = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.geran_info.base_station_identity_code = *(uint8_t *) get_next(1);
			res->data.geran_info.timing_advance = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.geran_info.rx_level = le16_to_cpu(*(uint16_t *) get_next(2));
			i = *(uint8_t *) get_next(1);
			res->data.geran_info.cell = __qmi_alloc_static(i * sizeof(res->data.geran_info.cell[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.geran_info.cell[res->data.geran_info.cell_n].cell_id = le32_to_cpu(*(uint32_t *) get_next(4));
				ii = 3;
				res->data.geran_info.cell[res->data.geran_info.cell_n].plmn = __qmi_copy_string(get_next(ii), ii);
				res->data.geran_info.cell[res->data.geran_info.cell_n].lac = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.geran_info.cell[res->data.geran_info.cell_n].geran_absolute_rf_channel_number = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.geran_info.cell[res->data.geran_info.cell_n].base_station_identity_code = *(uint8_t *) get_next(1);
				res->data.geran_info.cell[res->data.geran_info.cell_n].rx_level = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.geran_info.cell_n++;
			}
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			res->set.umts_info = 1;
			res->data.umts_info.cell_id = le16_to_cpu(*(uint16_t *) get_next(2));
			i = 3;
			res->data.umts_info.plmn = __qmi_copy_string(get_next(i), i);
			res->data.umts_info.lac = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.umts_info.utra_absolute_rf_channel_number = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.umts_info.primary_scrambling_code = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.umts_info.rscp = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.umts_info.ecio = le16_to_cpu(*(uint16_t *) get_next(2));
			i = *(uint8_t *) get_next(1);
			res->data.umts_info.cell = __qmi_alloc_static(i * sizeof(res->data.umts_info.cell[0]));
			while(i-- > 0) {
				res->data.umts_info.cell[res->data.umts_info.cell_n].utra_absolute_rf_channel_number = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.umts_info.cell[res->data.umts_info.cell_n].primary_scrambling_code = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.umts_info.cell[res->data.umts_info.cell_n].rscp = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.umts_info.cell[res->data.umts_info.cell_n].ecio = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.umts_info.cell_n++;
			}
			i = *(uint8_t *) get_next(1);
			res->data.umts_info.neighboring_geran = __qmi_alloc_static(i * sizeof(res->data.umts_info.neighboring_geran[0]));
			while(i-- > 0) {
				res->data.umts_info.neighboring_geran[res->data.umts_info.neighboring_geran_n].geran_absolute_rf_channel_number = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.umts_info.neighboring_geran[res->data.umts_info.neighboring_geran_n].network_color_code = *(uint8_t *) get_next(1);
				res->data.umts_info.neighboring_geran[res->data.umts_info.neighboring_geran_n].base_station_color_code = *(uint8_t *) get_next(1);
				res->data.umts_info.neighboring_geran[res->data.umts_info.neighboring_geran_n].rssi = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.umts_info.neighboring_geran_n++;
			}
			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			res->set.cdma_info = 1;
			res->data.cdma_info.system_id = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.cdma_info.network_id = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.cdma_info.base_station_id = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.cdma_info.reference_pn = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.cdma_info.latitude = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.cdma_info.longitude = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		case 0x13:
			if (found[0] & (1 << 4))
				break;

			found[0] |= (1 << 4);
			res->set.intrafrequency_lte_info = 1;
			res->data.intrafrequency_lte_info.ue_in_idle = *(uint8_t *) get_next(1);
			i = 3;
			res->data.intrafrequency_lte_info.plmn = __qmi_copy_string(get_next(i), i);
			res->data.intrafrequency_lte_info.tracking_area_code = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.intrafrequency_lte_info.global_cell_id = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.intrafrequency_lte_info.eutra_absolute_rf_channel_number = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.intrafrequency_lte_info.serving_cell_id = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.intrafrequency_lte_info.cell_reselection_priority = *(uint8_t *) get_next(1);
			res->data.intrafrequency_lte_info.s_non_intra_search_threshold = *(uint8_t *) get_next(1);
			res->data.intrafrequency_lte_info.serving_cell_low_threshold = *(uint8_t *) get_next(1);
			res->data.intrafrequency_lte_info.s_intra_search_threshold = *(uint8_t *) get_next(1);
			i = *(uint8_t *) get_next(1);
			res->data.intrafrequency_lte_info.cell = __qmi_alloc_static(i * sizeof(res->data.intrafrequency_lte_info.cell[0]));
			while(i-- > 0) {
				res->data.intrafrequency_lte_info.cell[res->data.intrafrequency_lte_info.cell_n].physical_cell_id = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.intrafrequency_lte_info.cell[res->data.intrafrequency_lte_info.cell_n].rsrq = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.intrafrequency_lte_info.cell[res->data.intrafrequency_lte_info.cell_n].rsrp = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.intrafrequency_lte_info.cell[res->data.intrafrequency_lte_info.cell_n].rssi = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.intrafrequency_lte_info.cell[res->data.intrafrequency_lte_info.cell_n].cell_selection_rx_level = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.intrafrequency_lte_info.cell_n++;
			}
			break;

		case 0x14:
			if (found[0] & (1 << 5))
				break;

			found[0] |= (1 << 5);
			res->set.interfrequency_lte_info = 1;
			res->data.interfrequency_lte_info.ue_in_idle = *(uint8_t *) get_next(1);
			i = *(uint8_t *) get_next(1);
			res->data.interfrequency_lte_info.frequency = __qmi_alloc_static(i * sizeof(res->data.interfrequency_lte_info.frequency[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].eutra_absolute_rf_channel_number = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell_selection_rx_level_low_threshold = *(uint8_t *) get_next(1);
				res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell_selection_rx_level_high_threshold = *(uint8_t *) get_next(1);
				res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell_reselection_priority = *(uint8_t *) get_next(1);
				ii = *(uint8_t *) get_next(1);
				res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell = __qmi_alloc_static(ii * sizeof(res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell[0]));
				while(ii-- > 0) {
					res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell[res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell_n].physical_cell_id = le16_to_cpu(*(uint16_t *) get_next(2));
					res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell[res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell_n].rsrq = le16_to_cpu(*(uint16_t *) get_next(2));
					res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell[res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell_n].rsrp = le16_to_cpu(*(uint16_t *) get_next(2));
					res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell[res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell_n].rssi = le16_to_cpu(*(uint16_t *) get_next(2));
					res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell[res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell_n].cell_selection_rx_level = le16_to_cpu(*(uint16_t *) get_next(2));
					res->data.interfrequency_lte_info.frequency[res->data.interfrequency_lte_info.frequency_n].cell_n++;
				}
				res->data.interfrequency_lte_info.frequency_n++;
			}
			break;

		case 0x15:
			if (found[0] & (1 << 6))
				break;

			found[0] |= (1 << 6);
			res->set.lte_info_neighboring_gsm = 1;
			res->data.lte_info_neighboring_gsm.ue_in_idle = *(uint8_t *) get_next(1);
			i = *(uint8_t *) get_next(1);
			res->data.lte_info_neighboring_gsm.frequency = __qmi_alloc_static(i * sizeof(res->data.lte_info_neighboring_gsm.frequency[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell_reselection_priority = *(uint8_t *) get_next(1);
				res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell_reselection_high_threshold = *(uint8_t *) get_next(1);
				res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell_reselection_low_threshold = *(uint8_t *) get_next(1);
				res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].ncc_permitted = *(uint8_t *) get_next(1);
				ii = *(uint8_t *) get_next(1);
				res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell = __qmi_alloc_static(ii * sizeof(res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell[0]));
				while(ii-- > 0) {
					res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell[res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell_n].geran_absolute_rf_channel_number = le16_to_cpu(*(uint16_t *) get_next(2));
					res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell[res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell_n].band_is_1900 = *(uint8_t *) get_next(1);
					res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell[res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell_n].cell_id_valid = *(uint8_t *) get_next(1);
					res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell[res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell_n].base_station_identity_code = *(uint8_t *) get_next(1);
					res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell[res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell_n].rssi = le16_to_cpu(*(uint16_t *) get_next(2));
					res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell[res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell_n].cell_selection_rx_level = le16_to_cpu(*(uint16_t *) get_next(2));
					res->data.lte_info_neighboring_gsm.frequency[res->data.lte_info_neighboring_gsm.frequency_n].cell_n++;
				}
				res->data.lte_info_neighboring_gsm.frequency_n++;
			}
			break;

		case 0x16:
			if (found[0] & (1 << 7))
				break;

			found[0] |= (1 << 7);
			res->set.lte_info_neighboring_wcdma = 1;
			res->data.lte_info_neighboring_wcdma.ue_in_idle = *(uint8_t *) get_next(1);
			i = *(uint8_t *) get_next(1);
			res->data.lte_info_neighboring_wcdma.frequency = __qmi_alloc_static(i * sizeof(res->data.lte_info_neighboring_wcdma.frequency[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].utra_absolute_rf_channel_number = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell_reselection_priority = *(uint8_t *) get_next(1);
				res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell_reselection_high_threshold = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell_reselection_low_threshold = le16_to_cpu(*(uint16_t *) get_next(2));
				ii = *(uint8_t *) get_next(1);
				res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell = __qmi_alloc_static(ii * sizeof(res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell[0]));
				while(ii-- > 0) {
					res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell[res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell_n].primary_scrambling_code = le16_to_cpu(*(uint16_t *) get_next(2));
					res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell[res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell_n].cpich_rscp = le16_to_cpu(*(uint16_t *) get_next(2));
					res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell[res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell_n].cpich_ecno = le16_to_cpu(*(uint16_t *) get_next(2));
					res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell[res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell_n].cell_selection_rx_level = le16_to_cpu(*(uint16_t *) get_next(2));
					res->data.lte_info_neighboring_wcdma.frequency[res->data.lte_info_neighboring_wcdma.frequency_n].cell_n++;
				}
				res->data.lte_info_neighboring_wcdma.frequency_n++;
			}
			break;

		case 0x17:
			if (found[0] & (1 << 8))
				break;

			found[0] |= (1 << 8);
			qmi_set(res, umts_cell_id, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x18:
			if (found[0] & (1 << 9))
				break;

			found[0] |= (1 << 9);
			res->set.umts_info_neighboring_lte = 1;
			res->data.umts_info_neighboring_lte.rrc_state = le32_to_cpu(*(uint32_t *) get_next(4));
			i = *(uint8_t *) get_next(1);
			res->data.umts_info_neighboring_lte.frequency = __qmi_alloc_static(i * sizeof(res->data.umts_info_neighboring_lte.frequency[0]));
			while(i-- > 0) {
				res->data.umts_info_neighboring_lte.frequency[res->data.umts_info_neighboring_lte.frequency_n].eutra_absolute_rf_channel_number = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.umts_info_neighboring_lte.frequency[res->data.umts_info_neighboring_lte.frequency_n].physical_cell_id = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.umts_info_neighboring_lte.frequency[res->data.umts_info_neighboring_lte.frequency_n].rsrp = ({ uint32_t data = le32_to_cpu(*(uint32_t *) get_next(4)); float _val; memcpy(&_val, &data, sizeof(_val)); _val; });
				res->data.umts_info_neighboring_lte.frequency[res->data.umts_info_neighboring_lte.frequency_n].rsrq = ({ uint32_t data = le32_to_cpu(*(uint32_t *) get_next(4)); float _val; memcpy(&_val, &data, sizeof(_val)); _val; });
				res->data.umts_info_neighboring_lte.frequency[res->data.umts_info_neighboring_lte.frequency_n].cell_selection_rx_level = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.umts_info_neighboring_lte.frequency[res->data.umts_info_neighboring_lte.frequency_n].is_tdd = *(uint8_t *) get_next(1);
				res->data.umts_info_neighboring_lte.frequency_n++;
			}
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_nas_get_system_info_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x004D);

	return 0;
}

int qmi_parse_nas_get_system_info_response(struct qmi_msg *msg, struct qmi_nas_get_system_info_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.cdma_service_status = 1;
			res->data.cdma_service_status.service_status = *(uint8_t *) get_next(1);
			res->data.cdma_service_status.preferred_data_path = *(uint8_t *) get_next(1);
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			res->set.hdr_service_status = 1;
			res->data.hdr_service_status.service_status = *(uint8_t *) get_next(1);
			res->data.hdr_service_status.preferred_data_path = *(uint8_t *) get_next(1);
			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			res->set.gsm_service_status = 1;
			res->data.gsm_service_status.service_status = *(uint8_t *) get_next(1);
			res->data.gsm_service_status.true_service_status = *(uint8_t *) get_next(1);
			res->data.gsm_service_status.preferred_data_path = *(uint8_t *) get_next(1);
			break;

		case 0x13:
			if (found[0] & (1 << 4))
				break;

			found[0] |= (1 << 4);
			res->set.wcdma_service_status = 1;
			res->data.wcdma_service_status.service_status = *(uint8_t *) get_next(1);
			res->data.wcdma_service_status.true_service_status = *(uint8_t *) get_next(1);
			res->data.wcdma_service_status.preferred_data_path = *(uint8_t *) get_next(1);
			break;

		case 0x14:
			if (found[0] & (1 << 5))
				break;

			found[0] |= (1 << 5);
			res->set.lte_service_status = 1;
			res->data.lte_service_status.service_status = *(uint8_t *) get_next(1);
			res->data.lte_service_status.true_service_status = *(uint8_t *) get_next(1);
			res->data.lte_service_status.preferred_data_path = *(uint8_t *) get_next(1);
			break;

		case 0x15:
			if (found[0] & (1 << 6))
				break;

			found[0] |= (1 << 6);
			res->set.cdma_system_info = 1;
			res->data.cdma_system_info.domain_valid = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.domain = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.service_capability_valid = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.service_capability = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.roaming_status_valid = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.roaming_status = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.forbidden_valid = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.forbidden = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.prl_match_valid = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.prl_match = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.p_rev_valid = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.p_rev = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.base_station_p_rev_valid = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.base_station_p_rev = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.concurrent_service_support_valid = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.concurrent_service_support = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.cdma_system_id_valid = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.sid = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.cdma_system_info.nid = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.cdma_system_info.base_station_info_valid = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.base_station_id = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.cdma_system_info.base_station_latitude = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.cdma_system_info.base_station_longitude = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.cdma_system_info.packet_zone_valid = *(uint8_t *) get_next(1);
			res->data.cdma_system_info.packet_zone = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.cdma_system_info.network_id_valid = *(uint8_t *) get_next(1);
			i = 3;
			res->data.cdma_system_info.mcc = __qmi_copy_string(get_next(i), i);
			i = 3;
			res->data.cdma_system_info.mnc = __qmi_copy_string(get_next(i), i);
			break;

		case 0x16:
			if (found[0] & (1 << 7))
				break;

			found[0] |= (1 << 7);
			res->set.hdr_system_info = 1;
			res->data.hdr_system_info.domain_valid = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.domain = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.service_capability_valid = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.service_capability = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.roaming_status_valid = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.roaming_status = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.forbidden_valid = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.forbidden = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.prl_match_valid = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.prl_match = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.personality_valid = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.personality = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.protocol_revision_valid = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.protocol_revision = *(uint8_t *) get_next(1);
			res->data.hdr_system_info.is_856_system_id_valid = *(uint8_t *) get_next(1);
			i = 16;
			res->data.hdr_system_info.is_856_system_id = __qmi_copy_string(get_next(i), i);
			break;

		case 0x17:
			if (found[0] & (1 << 8))
				break;

			found[0] |= (1 << 8);
			res->set.gsm_system_info = 1;
			res->data.gsm_system_info.domain_valid = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.domain = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.service_capability_valid = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.service_capability = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.roaming_status_valid = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.roaming_status = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.forbidden_valid = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.forbidden = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.lac_valid = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.lac = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.gsm_system_info.cid_valid = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.cid = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.gsm_system_info.registration_reject_info_valid = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.registration_reject_domain = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.registration_reject_cause = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.network_id_valid = *(uint8_t *) get_next(1);
			i = 3;
			res->data.gsm_system_info.mcc = __qmi_copy_string(get_next(i), i);
			i = 3;
			res->data.gsm_system_info.mnc = __qmi_copy_string(get_next(i), i);
			res->data.gsm_system_info.egprs_support_valid = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.egprs_support = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.dtm_support_valid = *(uint8_t *) get_next(1);
			res->data.gsm_system_info.dtm_support = *(uint8_t *) get_next(1);
			break;

		case 0x18:
			if (found[0] & (1 << 9))
				break;

			found[0] |= (1 << 9);
			res->set.wcdma_system_info = 1;
			res->data.wcdma_system_info.domain_valid = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.domain = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.service_capability_valid = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.service_capability = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.roaming_status_valid = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.roaming_status = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.forbidden_valid = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.forbidden = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.lac_valid = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.lac = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.wcdma_system_info.cid_valid = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.cid = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.wcdma_system_info.registration_reject_info_valid = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.registration_reject_domain = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.registration_reject_cause = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.network_id_valid = *(uint8_t *) get_next(1);
			i = 3;
			res->data.wcdma_system_info.mcc = __qmi_copy_string(get_next(i), i);
			i = 3;
			res->data.wcdma_system_info.mnc = __qmi_copy_string(get_next(i), i);
			res->data.wcdma_system_info.hs_call_status_valid = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.hs_call_status = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.hs_service_valid = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.hs_service = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.primary_scrambling_code_valid = *(uint8_t *) get_next(1);
			res->data.wcdma_system_info.primary_scrambling_code = le16_to_cpu(*(uint16_t *) get_next(2));
			break;

		case 0x19:
			if (found[0] & (1 << 10))
				break;

			found[0] |= (1 << 10);
			res->set.lte_system_info = 1;
			res->data.lte_system_info.domain_valid = *(uint8_t *) get_next(1);
			res->data.lte_system_info.domain = *(uint8_t *) get_next(1);
			res->data.lte_system_info.service_capability_valid = *(uint8_t *) get_next(1);
			res->data.lte_system_info.service_capability = *(uint8_t *) get_next(1);
			res->data.lte_system_info.roaming_status_valid = *(uint8_t *) get_next(1);
			res->data.lte_system_info.roaming_status = *(uint8_t *) get_next(1);
			res->data.lte_system_info.forbidden_valid = *(uint8_t *) get_next(1);
			res->data.lte_system_info.forbidden = *(uint8_t *) get_next(1);
			res->data.lte_system_info.lac_valid = *(uint8_t *) get_next(1);
			res->data.lte_system_info.lac = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.lte_system_info.cid_valid = *(uint8_t *) get_next(1);
			res->data.lte_system_info.cid = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.lte_system_info.registration_reject_info_valid = *(uint8_t *) get_next(1);
			res->data.lte_system_info.registration_reject_domain = *(uint8_t *) get_next(1);
			res->data.lte_system_info.registration_reject_cause = *(uint8_t *) get_next(1);
			res->data.lte_system_info.network_id_valid = *(uint8_t *) get_next(1);
			i = 3;
			res->data.lte_system_info.mcc = __qmi_copy_string(get_next(i), i);
			i = 3;
			res->data.lte_system_info.mnc = __qmi_copy_string(get_next(i), i);
			res->data.lte_system_info.tac_valid = *(uint8_t *) get_next(1);
			res->data.lte_system_info.tac = le16_to_cpu(*(uint16_t *) get_next(2));
			break;

		case 0x1A:
			if (found[0] & (1 << 11))
				break;

			found[0] |= (1 << 11);
			res->set.additional_cdma_system_info = 1;
			res->data.additional_cdma_system_info.geo_system_index = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.additional_cdma_system_info.registration_period = le16_to_cpu(*(uint16_t *) get_next(2));
			break;

		case 0x1B:
			if (found[0] & (1 << 12))
				break;

			found[0] |= (1 << 12);
			res->set.additional_hdr_system_info = 1;
			res->data.additional_hdr_system_info.geo_system_index = le16_to_cpu(*(uint16_t *) get_next(2));
			break;

		case 0x1C:
			if (found[0] & (1 << 13))
				break;

			found[0] |= (1 << 13);
			res->set.additional_gsm_system_info = 1;
			res->data.additional_gsm_system_info.geo_system_index = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.additional_gsm_system_info.cell_broadcast_support = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		case 0x1D:
			if (found[0] & (1 << 14))
				break;

			found[0] |= (1 << 14);
			res->set.additional_wcdma_system_info = 1;
			res->data.additional_wcdma_system_info.geo_system_index = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.additional_wcdma_system_info.cell_broadcast_support = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		case 0x1E:
			if (found[0] & (1 << 15))
				break;

			found[0] |= (1 << 15);
			res->set.additional_lte_system_info = 1;
			res->data.additional_lte_system_info.geo_system_index = le16_to_cpu(*(uint16_t *) get_next(2));
			break;

		case 0x1F:
			if (found[0] & (1 << 16))
				break;

			found[0] |= (1 << 16);
			res->set.gsm_call_barring_status = 1;
			res->data.gsm_call_barring_status.cs_status = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.gsm_call_barring_status.ps_status = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		case 0x20:
			if (found[0] & (1 << 17))
				break;

			found[0] |= (1 << 17);
			res->set.wcdma_call_barring_status = 1;
			res->data.wcdma_call_barring_status.cs_status = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.wcdma_call_barring_status.ps_status = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		case 0x21:
			if (found[0] & (1 << 18))
				break;

			found[0] |= (1 << 18);
			qmi_set(res, lte_voice_support, *(uint8_t *) get_next(1));
			break;

		case 0x22:
			if (found[0] & (1 << 19))
				break;

			found[0] |= (1 << 19);
			qmi_set(res, gsm_cipher_domain, *(uint8_t *) get_next(1));
			break;

		case 0x23:
			if (found[0] & (1 << 20))
				break;

			found[0] |= (1 << 20);
			qmi_set(res, wcdma_cipher_domain, *(uint8_t *) get_next(1));
			break;

		case 0x24:
			if (found[0] & (1 << 21))
				break;

			found[0] |= (1 << 21);
			res->set.td_scdma_service_status = 1;
			res->data.td_scdma_service_status.service_status = *(uint8_t *) get_next(1);
			res->data.td_scdma_service_status.true_service_status = *(uint8_t *) get_next(1);
			res->data.td_scdma_service_status.preferred_data_path = *(uint8_t *) get_next(1);
			break;

		case 0x25:
			if (found[0] & (1 << 22))
				break;

			found[0] |= (1 << 22);
			res->set.td_scdma_system_info = 1;
			res->data.td_scdma_system_info.domain_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.domain = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.service_capability_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.service_capability = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.roaming_status_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.roaming_status = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.forbidden_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.forbidden = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.lac_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.lac = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.td_scdma_system_info.cid_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.cid = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.td_scdma_system_info.registration_reject_info_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.registration_reject_domain = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.registration_reject_cause = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.network_id_valid = *(uint8_t *) get_next(1);
			i = 3;
			res->data.td_scdma_system_info.mcc = __qmi_copy_string(get_next(i), i);
			i = 3;
			res->data.td_scdma_system_info.mnc = __qmi_copy_string(get_next(i), i);
			res->data.td_scdma_system_info.hs_call_status_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.hs_call_status = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.hs_service_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.hs_service = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.cell_parameter_id_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.cell_parameter_id = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.td_scdma_system_info.cell_broadcast_support_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.cell_broadcast_support = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.td_scdma_system_info.cs_call_barring_status_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.cs_call_barring_status = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.td_scdma_system_info.ps_call_barring_status_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.ps_call_barring_status = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.td_scdma_system_info.cipher_domain_valid = *(uint8_t *) get_next(1);
			res->data.td_scdma_system_info.cipher_domain = *(uint8_t *) get_next(1);
			break;

		case 0x26:
			if (found[0] & (1 << 23))
				break;

			found[0] |= (1 << 23);
			qmi_set(res, lte_embms_coverage_info_support, *(uint8_t *) get_next(1));
			break;

		case 0x27:
			if (found[0] & (1 << 24))
				break;

			found[0] |= (1 << 24);
			qmi_set(res, sim_reject_info, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_nas_get_signal_info_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x004F);

	return 0;
}

int qmi_parse_nas_get_signal_info_response(struct qmi_msg *msg, struct qmi_nas_get_signal_info_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.cdma_signal_strength = 1;
			res->data.cdma_signal_strength.rssi = *(int8_t *) get_next(1);
			res->data.cdma_signal_strength.ecio = le16_to_cpu(*(uint16_t *) get_next(2));
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			res->set.hdr_signal_strength = 1;
			res->data.hdr_signal_strength.rssi = *(int8_t *) get_next(1);
			res->data.hdr_signal_strength.ecio = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.hdr_signal_strength.sinr = *(uint8_t *) get_next(1);
			res->data.hdr_signal_strength.io = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			qmi_set(res, gsm_signal_strength, *(int8_t *) get_next(1));
			break;

		case 0x13:
			if (found[0] & (1 << 4))
				break;

			found[0] |= (1 << 4);
			res->set.wcdma_signal_strength = 1;
			res->data.wcdma_signal_strength.rssi = *(int8_t *) get_next(1);
			res->data.wcdma_signal_strength.ecio = le16_to_cpu(*(uint16_t *) get_next(2));
			break;

		case 0x14:
			if (found[0] & (1 << 5))
				break;

			found[0] |= (1 << 5);
			res->set.lte_signal_strength = 1;
			res->data.lte_signal_strength.rssi = *(int8_t *) get_next(1);
			res->data.lte_signal_strength.rsrq = *(int8_t *) get_next(1);
			res->data.lte_signal_strength.rsrp = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.lte_signal_strength.snr = le16_to_cpu(*(uint16_t *) get_next(2));
			break;

		case 0x15:
			if (found[0] & (1 << 6))
				break;

			found[0] |= (1 << 6);
			qmi_set(res, tdma_signal_strength, *(int8_t *) get_next(1));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_nas_config_signal_info_request(struct qmi_msg *msg, struct qmi_nas_config_signal_info_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0050);

	if (req->data.rssi_threshold) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.rssi_threshold_n, 1);
		for (i = 0; i < req->data.rssi_threshold_n; i++) {
			put_tlv_var(uint8_t, req->data.rssi_threshold[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->data.ecio_threshold) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.ecio_threshold_n, 1);
		for (i = 0; i < req->data.ecio_threshold_n; i++) {
			put_tlv_var(uint16_t, cpu_to_le16(req->data.ecio_threshold[i]), 2);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	if (req->data.sinr_threshold) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.sinr_threshold_n, 1);
		for (i = 0; i < req->data.sinr_threshold_n; i++) {
			put_tlv_var(uint8_t, req->data.sinr_threshold[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x12, ofs, buf);
	}

	if (req->data.lte_snr_threshold) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.lte_snr_threshold_n, 1);
		for (i = 0; i < req->data.lte_snr_threshold_n; i++) {
			put_tlv_var(uint16_t, cpu_to_le16(req->data.lte_snr_threshold[i]), 2);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x13, ofs, buf);
	}

	if (req->data.io_threshold) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.io_threshold_n, 1);
		for (i = 0; i < req->data.io_threshold_n; i++) {
			put_tlv_var(uint32_t, cpu_to_le32(req->data.io_threshold[i]), 4);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x14, ofs, buf);
	}

	if (req->data.rsrq_threshold) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.rsrq_threshold_n, 1);
		for (i = 0; i < req->data.rsrq_threshold_n; i++) {
			put_tlv_var(uint8_t, req->data.rsrq_threshold[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x15, ofs, buf);
	}

	if (req->data.rsrp_threshold) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.rsrp_threshold_n, 1);
		for (i = 0; i < req->data.rsrp_threshold_n; i++) {
			put_tlv_var(uint16_t, cpu_to_le16(req->data.rsrp_threshold[i]), 2);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x16, ofs, buf);
	}

	if (req->set.lte_report) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.lte_report.rate, 1);
		put_tlv_var(uint8_t, req->data.lte_report.average_period, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x17, ofs, buf);
	}

	if (req->data.rscp_threshold) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.rscp_threshold_n, 1);
		for (i = 0; i < req->data.rscp_threshold_n; i++) {
			put_tlv_var(uint8_t, req->data.rscp_threshold[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x18, ofs, buf);
	}

	return 0;
}

int qmi_parse_nas_config_signal_info_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_nas_get_tx_rx_info_request(struct qmi_msg *msg, struct qmi_nas_get_tx_rx_info_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x005A);

	if (req->set.radio_interface) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.radio_interface, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_nas_get_tx_rx_info_response(struct qmi_msg *msg, struct qmi_nas_get_tx_rx_info_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.rx_chain_0_info = 1;
			res->data.rx_chain_0_info.is_radio_tuned = *(uint8_t *) get_next(1);
			res->data.rx_chain_0_info.rx_power = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.rx_chain_0_info.ecio = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.rx_chain_0_info.rscp = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.rx_chain_0_info.rsrp = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.rx_chain_0_info.phase = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			res->set.rx_chain_1_info = 1;
			res->data.rx_chain_1_info.is_radio_tuned = *(uint8_t *) get_next(1);
			res->data.rx_chain_1_info.rx_power = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.rx_chain_1_info.ecio = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.rx_chain_1_info.rscp = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.rx_chain_1_info.rsrp = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.rx_chain_1_info.phase = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			res->set.tx_info = 1;
			res->data.tx_info.is_in_traffic = *(uint8_t *) get_next(1);
			res->data.tx_info.tx_power = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_nas_get_cdma_position_info_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_NAS);
	msg->svc.message = cpu_to_le16(0x0065);

	return 0;
}

int qmi_parse_nas_get_cdma_position_info_response(struct qmi_msg *msg, struct qmi_nas_get_cdma_position_info_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.cdma_position_info = 1;
			res->data.cdma_position_info.ui_in_idle_mode = *(int8_t *) get_next(1);
			i = *(uint8_t *) get_next(1);
			res->data.cdma_position_info.basestations = __qmi_alloc_static(i * sizeof(res->data.cdma_position_info.basestations[0]));
			while(i-- > 0) {
				res->data.cdma_position_info.basestations[res->data.cdma_position_info.basestations_n].pilot_type = le32_to_cpu(*(uint32_t *) get_next(4));
				res->data.cdma_position_info.basestations[res->data.cdma_position_info.basestations_n].system_id = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.cdma_position_info.basestations[res->data.cdma_position_info.basestations_n].network_id = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.cdma_position_info.basestations[res->data.cdma_position_info.basestations_n].base_station_id = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.cdma_position_info.basestations[res->data.cdma_position_info.basestations_n].pilot_pn = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.cdma_position_info.basestations[res->data.cdma_position_info.basestations_n].pilot_strength = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.cdma_position_info.basestations[res->data.cdma_position_info.basestations_n].latitude = le32_to_cpu(*(uint32_t *) get_next(4));
				res->data.cdma_position_info.basestations[res->data.cdma_position_info.basestations_n].longitude = le32_to_cpu(*(uint32_t *) get_next(4));
				res->data.cdma_position_info.basestations[res->data.cdma_position_info.basestations_n].gps_time_in_milliseconds = le64_to_cpu(*(uint64_t *) get_next(8));
				res->data.cdma_position_info.basestations_n++;
			}
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

