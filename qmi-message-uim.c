/* generated by uqmi gen-code.pl */
#include <stdio.h>
#include <string.h>
#include "qmi-message.h"

#define get_next(_size) ({ void *_buf = &tlv->data[ofs]; ofs += _size; if (ofs > cur_tlv_len) goto error_len; _buf; })
#define copy_tlv(_val, _size) \
	do { \
		unsigned int __size = _size; \
		if (__size > 0) \
			memcpy(__qmi_alloc_static(__size), _val, __size); \
	} while (0);

#define put_tlv_var(_type, _val, _size) \
	do { \
		_type __var = _val; \
		copy_tlv(&__var, _size); \
	} while(0)

int qmi_set_uim_reset_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0000);

	return 0;
}

int qmi_parse_uim_reset_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_uim_get_supported_messages_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x001E);

	return 0;
}

int qmi_parse_uim_get_supported_messages_response(struct qmi_msg *msg, struct qmi_uim_get_supported_messages_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.list = __qmi_alloc_static(i * sizeof(res->data.list[0]));
			while(i-- > 0) {
				res->data.list[res->data.list_n] = *(uint8_t *) get_next(1);
				res->data.list_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_read_transparent_request(struct qmi_msg *msg, struct qmi_uim_read_transparent_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0020);

	if (req->set.session_information) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session_information.session_type, 1);
		i = strlen(req->data.session_information.application_identifier);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.session_information.application_identifier, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.file) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.file.file_id), 2);
		put_tlv_var(uint8_t, req->data.file.file_path_n, 1);
		for (i = 0; i < req->data.file.file_path_n; i++) {
			put_tlv_var(uint8_t, req->data.file.file_path[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.read_information) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.read_information.offset), 2);
		put_tlv_var(uint16_t, cpu_to_le16(req->data.read_information.length), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x03, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->set.encrypt_data) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.encrypt_data, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_read_transparent_response(struct qmi_msg *msg, struct qmi_uim_read_transparent_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.card_result = 1;
			res->data.card_result.sw1 = *(uint8_t *) get_next(1);
			res->data.card_result.sw2 = *(uint8_t *) get_next(1);
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.read_result = __qmi_alloc_static(i * sizeof(res->data.read_result[0]));
			while(i-- > 0) {
				res->data.read_result[res->data.read_result_n] = *(uint8_t *) get_next(1);
				res->data.read_result_n++;
			}

			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x13:
			if (found[0] & (1 << 4))
				break;

			found[0] |= (1 << 4);
			qmi_set(res, encrypted_data, *(uint8_t *) get_next(1));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_read_record_request(struct qmi_msg *msg, struct qmi_uim_read_record_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0021);

	if (req->set.session_information) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session_information.session_type, 1);
		i = strlen(req->data.session_information.application_identifier);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.session_information.application_identifier, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.file) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.file.file_id), 2);
		put_tlv_var(uint8_t, req->data.file.file_path_n, 1);
		for (i = 0; i < req->data.file.file_path_n; i++) {
			put_tlv_var(uint8_t, req->data.file.file_path[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.record) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.record.record_number), 2);
		put_tlv_var(uint16_t, cpu_to_le16(req->data.record.record_length), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x03, ofs, buf);
	}

	if (req->set.last_record) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.last_record), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_read_record_response(struct qmi_msg *msg, struct qmi_uim_read_record_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.card_result = 1;
			res->data.card_result.sw1 = *(uint8_t *) get_next(1);
			res->data.card_result.sw2 = *(uint8_t *) get_next(1);
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.read_result = __qmi_alloc_static(i * sizeof(res->data.read_result[0]));
			while(i-- > 0) {
				res->data.read_result[res->data.read_result_n] = *(uint8_t *) get_next(1);
				res->data.read_result_n++;
			}

			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.additional_read_result = __qmi_alloc_static(i * sizeof(res->data.additional_read_result[0]));
			while(i-- > 0) {
				res->data.additional_read_result[res->data.additional_read_result_n] = *(uint8_t *) get_next(1);
				res->data.additional_read_result_n++;
			}

			break;

		case 0x13:
			if (found[0] & (1 << 4))
				break;

			found[0] |= (1 << 4);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_get_file_attributes_request(struct qmi_msg *msg, struct qmi_uim_get_file_attributes_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0024);

	if (req->set.session_information) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session_information.session_type, 1);
		i = strlen(req->data.session_information.application_identifier);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.session_information.application_identifier, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.file) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.file.file_id), 2);
		put_tlv_var(uint8_t, req->data.file.file_path_n, 1);
		for (i = 0; i < req->data.file.file_path_n; i++) {
			put_tlv_var(uint8_t, req->data.file.file_path[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_get_file_attributes_response(struct qmi_msg *msg, struct qmi_uim_get_file_attributes_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.card_result = 1;
			res->data.card_result.sw1 = *(uint8_t *) get_next(1);
			res->data.card_result.sw2 = *(uint8_t *) get_next(1);
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			res->set.file_attributes = 1;
			res->data.file_attributes.file_size = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.file_id = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.file_type = *(uint8_t *) get_next(1);
			res->data.file_attributes.record_size = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.record_count = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.read_security_attributes_logic = *(uint8_t *) get_next(1);
			res->data.file_attributes.read_security_attributes = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.write_security_attributes_logic = *(uint8_t *) get_next(1);
			res->data.file_attributes.write_security_attributes = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.increase_security_attributes_logic = *(uint8_t *) get_next(1);
			res->data.file_attributes.increase_security_attributes = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.deactivate_security_attributes_logic = *(uint8_t *) get_next(1);
			res->data.file_attributes.deactivate_security_attributes = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.activate_security_attributes_logic = *(uint8_t *) get_next(1);
			res->data.file_attributes.activate_security_attributes = le16_to_cpu(*(uint16_t *) get_next(2));
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.raw_data = __qmi_alloc_static(i * sizeof(res->data.file_attributes.raw_data[0]));
			while(i-- > 0) {
				res->data.file_attributes.raw_data[res->data.file_attributes.raw_data_n] = *(uint8_t *) get_next(1);
				res->data.file_attributes.raw_data_n++;
			}
			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_set_pin_protection_request(struct qmi_msg *msg, struct qmi_uim_set_pin_protection_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0025);

	if (req->set.session_information) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session_information.session_type, 1);
		i = strlen(req->data.session_information.application_identifier);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.session_information.application_identifier, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.pin_id, 1);
		put_tlv_var(uint8_t, req->data.info.pin_enabled, 1);
		i = strlen(req->data.info.pin_value);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.pin_value, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_set_pin_protection_response(struct qmi_msg *msg, struct qmi_uim_set_pin_protection_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.retries_remaining = 1;
			res->data.retries_remaining.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.retries_remaining.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		case 0x12:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_verify_pin_request(struct qmi_msg *msg, struct qmi_uim_verify_pin_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0026);

	if (req->set.session_information) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session_information.session_type, 1);
		i = strlen(req->data.session_information.application_identifier);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.session_information.application_identifier, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.pin_id, 1);
		i = strlen(req->data.info.pin_value);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.pin_value, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x12, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_verify_pin_response(struct qmi_msg *msg, struct qmi_uim_verify_pin_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.retries_remaining = 1;
			res->data.retries_remaining.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.retries_remaining.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		case 0x12:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x13:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			res->set.card_result = 1;
			res->data.card_result.sw1 = *(uint8_t *) get_next(1);
			res->data.card_result.sw2 = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_unblock_pin_request(struct qmi_msg *msg, struct qmi_uim_unblock_pin_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0027);

	if (req->set.session_information) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session_information.session_type, 1);
		i = strlen(req->data.session_information.application_identifier);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.session_information.application_identifier, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.pin_id, 1);
		i = strlen(req->data.info.puk);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.puk, i);
		i = strlen(req->data.info.new_pin);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.new_pin, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_unblock_pin_response(struct qmi_msg *msg, struct qmi_uim_unblock_pin_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.retries_remaining = 1;
			res->data.retries_remaining.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.retries_remaining.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		case 0x12:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x13:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			res->set.card_result = 1;
			res->data.card_result.sw1 = *(uint8_t *) get_next(1);
			res->data.card_result.sw2 = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_change_pin_request(struct qmi_msg *msg, struct qmi_uim_change_pin_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0028);

	if (req->set.session_information) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session_information.session_type, 1);
		i = strlen(req->data.session_information.application_identifier);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.session_information.application_identifier, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.pin_id, 1);
		i = strlen(req->data.info.old_pin);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.old_pin, i);
		i = strlen(req->data.info.new_pin);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.new_pin, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_change_pin_response(struct qmi_msg *msg, struct qmi_uim_change_pin_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.retries_remaining = 1;
			res->data.retries_remaining.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.retries_remaining.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		case 0x12:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x13:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			res->set.card_result = 1;
			res->data.card_result.sw1 = *(uint8_t *) get_next(1);
			res->data.card_result.sw2 = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_get_card_status_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x002F);

	return 0;
}

int qmi_parse_uim_get_card_status_response(struct qmi_msg *msg, struct qmi_uim_get_card_status_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.card_status = 1;
			res->data.card_status.index_gw_primary = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.card_status.index_1x_primary = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.card_status.index_gw_secondary_ = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.card_status.index_1x_secondary = le16_to_cpu(*(uint16_t *) get_next(2));
			i = *(uint8_t *) get_next(1);
			res->data.card_status.cards = __qmi_alloc_static(i * sizeof(res->data.card_status.cards[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.card_status.cards[res->data.card_status.cards_n].card_state = *(uint8_t *) get_next(1);
				res->data.card_status.cards[res->data.card_status.cards_n].upin_state = *(uint8_t *) get_next(1);
				res->data.card_status.cards[res->data.card_status.cards_n].upin_retries = *(uint8_t *) get_next(1);
				res->data.card_status.cards[res->data.card_status.cards_n].upuk_retries = *(uint8_t *) get_next(1);
				res->data.card_status.cards[res->data.card_status.cards_n].error_code = *(uint8_t *) get_next(1);
				ii = *(uint8_t *) get_next(1);
				res->data.card_status.cards[res->data.card_status.cards_n].applications = __qmi_alloc_static(ii * sizeof(res->data.card_status.cards[res->data.card_status.cards_n].applications[0]));
				while(ii-- > 0) {
					unsigned int iii;
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].type = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].state = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].personalization_state = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].personalization_feature = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].personalization_retries = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].personalization_unblock_retries = *(uint8_t *) get_next(1);
					iii = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].application_identifier_value = __qmi_alloc_static(iii * sizeof(res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].application_identifier_value[0]));
					while(iii-- > 0) {
						res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].application_identifier_value[res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].application_identifier_value_n] = *(uint8_t *) get_next(1);
						res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].application_identifier_value_n++;
					}
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].upin_replaces_pin1 = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].pin1_state = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].pin1_retries = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].puk1_retries = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].pin2_state = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].pin2_retries = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].puk2_retries = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications_n++;
				}
				res->data.card_status.cards_n++;
			}
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

