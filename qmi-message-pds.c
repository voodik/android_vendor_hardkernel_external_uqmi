/* generated by uqmi gen-code.pl */
#include <stdio.h>
#include <string.h>
#include "qmi-message.h"

#define get_next(_size) ({ void *_buf = &tlv->data[ofs]; ofs += _size; if (ofs > cur_tlv_len) goto error_len; _buf; })
#define copy_tlv(_val, _size) \
	do { \
		unsigned int __size = _size; \
		if (__size > 0) \
			memcpy(__qmi_alloc_static(__size), _val, __size); \
	} while (0);

#define put_tlv_var(_type, _val, _size) \
	do { \
		_type __var = _val; \
		copy_tlv(&__var, _size); \
	} while(0)

int qmi_set_pds_reset_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_PDS);
	msg->svc.message = cpu_to_le16(0x0000);

	return 0;
}

int qmi_parse_pds_reset_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_pds_set_event_report_request(struct qmi_msg *msg, struct qmi_pds_set_event_report_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_PDS);
	msg->svc.message = cpu_to_le16(0x0001);

	if (req->set.nmea_position_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.nmea_position_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->set.extended_nmea_position_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.extended_nmea_position_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	if (req->set.parsed_position_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.parsed_position_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x12, ofs, buf);
	}

	if (req->set.external_xtra_data_request_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.external_xtra_data_request_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x13, ofs, buf);
	}

	if (req->set.external_time_injection_request_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.external_time_injection_request_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x14, ofs, buf);
	}

	if (req->set.external_wifi_position_request_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.external_wifi_position_request_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x15, ofs, buf);
	}

	if (req->set.satellite_information_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.satellite_information_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x16, ofs, buf);
	}

	if (req->set.vx_network_initiated_request_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.vx_network_initiated_request_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x17, ofs, buf);
	}

	if (req->set.supl_network_initiated_prompt_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.supl_network_initiated_prompt_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x18, ofs, buf);
	}

	if (req->set.umts_cp_network_initiated_prompt_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.umts_cp_network_initiated_prompt_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x19, ofs, buf);
	}

	if (req->set.pds_comm_event_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.pds_comm_event_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1A, ofs, buf);
	}

	if (req->set.accelerometer_data_streaming_ready_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.accelerometer_data_streaming_ready_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1B, ofs, buf);
	}

	if (req->set.gyro_data_streaming_ready_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.gyro_data_streaming_ready_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1C, ofs, buf);
	}

	if (req->set.time_sync_request_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.time_sync_request_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1D, ofs, buf);
	}

	if (req->set.position_reliability_indicator_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.position_reliability_indicator_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1E, ofs, buf);
	}

	if (req->set.sensor_data_usage_indicator_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.sensor_data_usage_indicator_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x1F, ofs, buf);
	}

	if (req->set.time_source_information_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.time_source_information_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x20, ofs, buf);
	}

	if (req->set.heading_uncertainty_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.heading_uncertainty_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x21, ofs, buf);
	}

	if (req->set.nmea_debug_strings_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.nmea_debug_strings_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x22, ofs, buf);
	}

	if (req->set.extended_external_xtra_data_request_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.extended_external_xtra_data_request_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x23, ofs, buf);
	}

	return 0;
}

int qmi_parse_pds_set_event_report_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_pds_get_gps_service_state_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_PDS);
	msg->svc.message = cpu_to_le16(0x0020);

	return 0;
}

int qmi_parse_pds_get_gps_service_state_response(struct qmi_msg *msg, struct qmi_pds_get_gps_service_state_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.state = 1;
			res->data.state.gps_service_state = *(uint8_t *) get_next(1);
			res->data.state.tracking_session_state = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_pds_set_gps_service_state_request(struct qmi_msg *msg, struct qmi_pds_set_gps_service_state_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_PDS);
	msg->svc.message = cpu_to_le16(0x0021);

	if (req->set.state) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.state.gps_service_state, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_pds_set_gps_service_state_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_pds_get_default_tracking_session_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_PDS);
	msg->svc.message = cpu_to_le16(0x0029);

	return 0;
}

int qmi_parse_pds_get_default_tracking_session_response(struct qmi_msg *msg, struct qmi_pds_get_default_tracking_session_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.info = 1;
			res->data.info.session_operation = *(uint8_t *) get_next(1);
			res->data.info.position_data_timeout = *(uint8_t *) get_next(1);
			res->data.info.interval = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.info.accuracy_threshold = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_pds_set_default_tracking_session_request(struct qmi_msg *msg, struct qmi_pds_set_default_tracking_session_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_PDS);
	msg->svc.message = cpu_to_le16(0x002A);

	if (req->set.info) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.session_operation, 1);
		put_tlv_var(uint8_t, req->data.info.position_data_timeout, 1);
		put_tlv_var(uint32_t, cpu_to_le32(req->data.info.interval), 4);
		put_tlv_var(uint32_t, cpu_to_le32(req->data.info.accuracy_threshold), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_pds_set_default_tracking_session_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_pds_get_agps_config_request(struct qmi_msg *msg, struct qmi_pds_get_agps_config_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_PDS);
	msg->svc.message = cpu_to_le16(0x002E);

	if (req->set.network_mode) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.network_mode, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x12, ofs, buf);
	}

	return 0;
}

int qmi_parse_pds_get_agps_config_response(struct qmi_msg *msg, struct qmi_pds_get_agps_config_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.location_server_address = 1;
			res->data.location_server_address.ip = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.location_server_address.port = le32_to_cpu(*(uint32_t *) get_next(4));
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			i = *(uint8_t *) get_next(1);
			res->data.location_server_url = __qmi_alloc_static(i * sizeof(res->data.location_server_url[0]));
			while(i-- > 0) {
				res->data.location_server_url[res->data.location_server_url_n] = *(uint8_t *) get_next(1);
				res->data.location_server_url_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_pds_set_agps_config_request(struct qmi_msg *msg, struct qmi_pds_set_agps_config_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_PDS);
	msg->svc.message = cpu_to_le16(0x002F);

	if (req->set.location_server_address) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.location_server_address.ip), 4);
		put_tlv_var(uint32_t, cpu_to_le32(req->data.location_server_address.port), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->data.location_server_url) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.location_server_url_n, 1);
		for (i = 0; i < req->data.location_server_url_n; i++) {
			put_tlv_var(uint8_t, req->data.location_server_url[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	if (req->set.network_mode) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.network_mode, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x14, ofs, buf);
	}

	return 0;
}

int qmi_parse_pds_set_agps_config_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_pds_get_auto_tracking_state_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_PDS);
	msg->svc.message = cpu_to_le16(0x0030);

	return 0;
}

int qmi_parse_pds_get_auto_tracking_state_response(struct qmi_msg *msg, struct qmi_pds_get_auto_tracking_state_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.state = 1;
			res->data.state.auto_tracking_state = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_pds_set_auto_tracking_state_request(struct qmi_msg *msg, struct qmi_pds_set_auto_tracking_state_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_PDS);
	msg->svc.message = cpu_to_le16(0x0031);

	if (req->set.state) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.state.auto_tracking_state, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_pds_set_auto_tracking_state_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

