/* generated by uqmi gen-code.pl */
#include <stdio.h>
#include <string.h>
#include "qmi-message.h"

#define get_next(_size) ({ void *_buf = &tlv->data[ofs]; ofs += _size; if (ofs > cur_tlv_len) goto error_len; _buf; })
#define copy_tlv(_val, _size) \
	do { \
		unsigned int __size = _size; \
		if (__size > 0) \
			memcpy(__qmi_alloc_static(__size), _val, __size); \
	} while (0);

#define put_tlv_var(_type, _val, _size) \
	do { \
		_type __var = _val; \
		copy_tlv(&__var, _size); \
	} while(0)

int qmi_set_dms_reset_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0000);

	return 0;
}

int qmi_parse_dms_reset_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_set_event_report_request(struct qmi_msg *msg, struct qmi_dms_set_event_report_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0001);

	if (req->set.power_state_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.power_state_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->set.battery_level_report_limits) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.battery_level_report_limits.lower_limit, 1);
		put_tlv_var(uint8_t, req->data.battery_level_report_limits.upper_limit, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	if (req->set.pin_state_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.pin_state_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x12, ofs, buf);
	}

	if (req->set.activation_state_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.activation_state_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x13, ofs, buf);
	}

	if (req->set.operating_mode_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.operating_mode_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x14, ofs, buf);
	}

	if (req->set.uim_state_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.uim_state_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x15, ofs, buf);
	}

	if (req->set.wireless_disable_state_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.wireless_disable_state_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x16, ofs, buf);
	}

	if (req->set.prl_init_reporting) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.prl_init_reporting, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x17, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_set_event_report_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_get_capabilities_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0020);

	return 0;
}

int qmi_parse_dms_get_capabilities_response(struct qmi_msg *msg, struct qmi_dms_get_capabilities_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.info = 1;
			res->data.info.max_tx_channel_rate = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.info.max_rx_channel_rate = le32_to_cpu(*(uint32_t *) get_next(4));
			res->data.info.data_service_capability = *(uint8_t *) get_next(1);
			res->data.info.sim_capability = *(uint8_t *) get_next(1);
			i = *(uint8_t *) get_next(1);
			res->data.info.radio_interface_list = __qmi_alloc_static(i * sizeof(res->data.info.radio_interface_list[0]));
			while(i-- > 0) {
				res->data.info.radio_interface_list[res->data.info.radio_interface_list_n] = *(uint8_t *) get_next(1);
				res->data.info.radio_interface_list_n++;
			}
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_manufacturer_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0021);

	return 0;
}

int qmi_parse_dms_get_manufacturer_response(struct qmi_msg *msg, struct qmi_dms_get_manufacturer_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = cur_tlv_len - ofs;
			res->data.manufacturer = __qmi_copy_string(get_next(i), i);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_model_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0022);

	return 0;
}

int qmi_parse_dms_get_model_response(struct qmi_msg *msg, struct qmi_dms_get_model_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = cur_tlv_len - ofs;
			res->data.model = __qmi_copy_string(get_next(i), i);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_revision_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0023);

	return 0;
}

int qmi_parse_dms_get_revision_response(struct qmi_msg *msg, struct qmi_dms_get_revision_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = cur_tlv_len - ofs;
			res->data.revision = __qmi_copy_string(get_next(i), i);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_msisdn_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0024);

	return 0;
}

int qmi_parse_dms_get_msisdn_response(struct qmi_msg *msg, struct qmi_dms_get_msisdn_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = cur_tlv_len - ofs;
			res->data.msisdn = __qmi_copy_string(get_next(i), i);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_ids_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0025);

	return 0;
}

int qmi_parse_dms_get_ids_response(struct qmi_msg *msg, struct qmi_dms_get_ids_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = cur_tlv_len - ofs;
			res->data.esn = __qmi_copy_string(get_next(i), i);
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			i = cur_tlv_len - ofs;
			if (i > 15)
				i = 15;
			res->data.imei = __qmi_copy_string(get_next(i), i);
			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			i = cur_tlv_len - ofs;
			res->data.meid = __qmi_copy_string(get_next(i), i);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_power_state_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0026);

	return 0;
}

int qmi_parse_dms_get_power_state_response(struct qmi_msg *msg, struct qmi_dms_get_power_state_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.info = 1;
			res->data.info.power_state_flags = *(uint8_t *) get_next(1);
			res->data.info.battery_level = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_uim_set_pin_protection_request(struct qmi_msg *msg, struct qmi_dms_uim_set_pin_protection_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0027);

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.pin_id, 1);
		put_tlv_var(uint8_t, req->data.info.protection_enabled, 1);
		i = strlen(req->data.info.pin);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.pin, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_uim_set_pin_protection_response(struct qmi_msg *msg, struct qmi_dms_uim_set_pin_protection_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.pin_retries_status = 1;
			res->data.pin_retries_status.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.pin_retries_status.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_uim_verify_pin_request(struct qmi_msg *msg, struct qmi_dms_uim_verify_pin_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0028);

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.pin_id, 1);
		i = strlen(req->data.info.pin);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.pin, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_uim_verify_pin_response(struct qmi_msg *msg, struct qmi_dms_uim_verify_pin_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.pin_retries_status = 1;
			res->data.pin_retries_status.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.pin_retries_status.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_uim_unblock_pin_request(struct qmi_msg *msg, struct qmi_dms_uim_unblock_pin_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0029);

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.pin_id, 1);
		i = strlen(req->data.info.puk);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.puk, i);
		i = strlen(req->data.info.new_pin);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.new_pin, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_uim_unblock_pin_response(struct qmi_msg *msg, struct qmi_dms_uim_unblock_pin_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.pin_retries_status = 1;
			res->data.pin_retries_status.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.pin_retries_status.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_uim_change_pin_request(struct qmi_msg *msg, struct qmi_dms_uim_change_pin_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x002A);

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.pin_id, 1);
		i = strlen(req->data.info.old_pin);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.old_pin, i);
		i = strlen(req->data.info.new_pin);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.new_pin, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_uim_change_pin_response(struct qmi_msg *msg, struct qmi_dms_uim_change_pin_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.pin_retries_status = 1;
			res->data.pin_retries_status.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.pin_retries_status.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_uim_get_pin_status_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x002B);

	return 0;
}

int qmi_parse_dms_uim_get_pin_status_response(struct qmi_msg *msg, struct qmi_dms_uim_get_pin_status_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x11:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.pin1_status = 1;
			res->data.pin1_status.current_status = *(uint8_t *) get_next(1);
			res->data.pin1_status.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.pin1_status.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		case 0x12:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			res->set.pin2_status = 1;
			res->data.pin2_status.current_status = *(uint8_t *) get_next(1);
			res->data.pin2_status.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.pin2_status.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_hardware_revision_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x002C);

	return 0;
}

int qmi_parse_dms_get_hardware_revision_response(struct qmi_msg *msg, struct qmi_dms_get_hardware_revision_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = cur_tlv_len - ofs;
			res->data.revision = __qmi_copy_string(get_next(i), i);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_operating_mode_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x002D);

	return 0;
}

int qmi_parse_dms_get_operating_mode_response(struct qmi_msg *msg, struct qmi_dms_get_operating_mode_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, mode, *(uint8_t *) get_next(1));
			break;

		case 0x10:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, offline_reason, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		case 0x11:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			qmi_set(res, hardware_restricted_mode, *(uint8_t *) get_next(1));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_set_operating_mode_request(struct qmi_msg *msg, struct qmi_dms_set_operating_mode_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x002E);

	if (req->set.mode) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.mode, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_set_operating_mode_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_get_time_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x002F);

	return 0;
}

int qmi_parse_dms_get_time_response(struct qmi_msg *msg, struct qmi_dms_get_time_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.device_time = 1;
			res->data.device_time.time_count = ({ uint64_t var; memcpy(&var, get_next(6), 6); le64_to_cpu(var); });
			res->data.device_time.time_source = le16_to_cpu(*(uint16_t *) get_next(2));
			break;

		case 0x10:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, system_time, le64_to_cpu(*(uint64_t *) get_next(8)));
			break;

		case 0x11:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			qmi_set(res, user_time, le64_to_cpu(*(uint64_t *) get_next(8)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_prl_version_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0030);

	return 0;
}

int qmi_parse_dms_get_prl_version_response(struct qmi_msg *msg, struct qmi_dms_get_prl_version_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, version, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		case 0x10:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, prl_only_preference, *(uint8_t *) get_next(1));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_activation_state_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0031);

	return 0;
}

int qmi_parse_dms_get_activation_state_response(struct qmi_msg *msg, struct qmi_dms_get_activation_state_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, info, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_activate_automatic_request(struct qmi_msg *msg, struct qmi_dms_activate_automatic_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0032);

	if (req->data.activation_code) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		i = strlen(req->data.activation_code);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.activation_code, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_activate_automatic_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_activate_manual_request(struct qmi_msg *msg, struct qmi_dms_activate_manual_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0033);

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		i = 6;
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.service_programming_code, i);
		put_tlv_var(uint16_t, cpu_to_le16(req->data.info.system_identification_number), 2);
		i = strlen(req->data.info.mobile_directory_number);
		if (i > 15)
			i = 15;
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.mobile_directory_number, i);
		i = strlen(req->data.info.mobile_identification_number);
		if (i > 15)
			i = 15;
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.mobile_identification_number, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->data.mn_ha_key) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		i = strlen(req->data.mn_ha_key);
		if (i > 16)
			i = 16;
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.mn_ha_key, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	if (req->data.mn_aaa_key) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		i = strlen(req->data.mn_aaa_key);
		if (i > 16)
			i = 16;
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.mn_aaa_key, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x12, ofs, buf);
	}

	if (req->set.prl) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.prl.prl_total_length), 2);
		put_tlv_var(uint16_t, cpu_to_le16(req->data.prl.prl_segment_n), 2);
		for (i = 0; i < req->data.prl.prl_segment_n; i++) {
			put_tlv_var(uint8_t, req->data.prl.prl_segment[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x13, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_activate_manual_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_get_user_lock_state_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0034);

	return 0;
}

int qmi_parse_dms_get_user_lock_state_response(struct qmi_msg *msg, struct qmi_dms_get_user_lock_state_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, enabled, *(uint8_t *) get_next(1));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_set_user_lock_state_request(struct qmi_msg *msg, struct qmi_dms_set_user_lock_state_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0035);

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.enabled, 1);
		i = 4;
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.lock_code, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_set_user_lock_state_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_set_user_lock_code_request(struct qmi_msg *msg, struct qmi_dms_set_user_lock_code_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0036);

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		i = 4;
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.old_code, i);
		i = 4;
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.new_code, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_set_user_lock_code_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_read_user_data_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0037);

	return 0;
}

int qmi_parse_dms_read_user_data_response(struct qmi_msg *msg, struct qmi_dms_read_user_data_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.user_data = __qmi_alloc_static(i * sizeof(res->data.user_data[0]));
			while(i-- > 0) {
				res->data.user_data[res->data.user_data_n] = *(uint8_t *) get_next(1);
				res->data.user_data_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_write_user_data_request(struct qmi_msg *msg, struct qmi_dms_write_user_data_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0038);

	if (req->data.user_data) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.user_data_n), 2);
		for (i = 0; i < req->data.user_data_n; i++) {
			put_tlv_var(uint8_t, req->data.user_data[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_write_user_data_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_read_eri_file_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0039);

	return 0;
}

int qmi_parse_dms_read_eri_file_response(struct qmi_msg *msg, struct qmi_dms_read_eri_file_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.eri_file = __qmi_alloc_static(i * sizeof(res->data.eri_file[0]));
			while(i-- > 0) {
				res->data.eri_file[res->data.eri_file_n] = *(uint8_t *) get_next(1);
				res->data.eri_file_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_restore_factory_defaults_request(struct qmi_msg *msg, struct qmi_dms_restore_factory_defaults_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x003A);

	if (req->data.service_programming_code) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		i = 6;
		strncpy(__qmi_alloc_static(i), req->data.service_programming_code, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_restore_factory_defaults_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_validate_service_programming_code_request(struct qmi_msg *msg, struct qmi_dms_validate_service_programming_code_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x003B);

	if (req->data.service_programming_code) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		i = 6;
		strncpy(__qmi_alloc_static(i), req->data.service_programming_code, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_validate_service_programming_code_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_uim_get_iccid_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x003C);

	return 0;
}

int qmi_parse_dms_uim_get_iccid_response(struct qmi_msg *msg, struct qmi_dms_uim_get_iccid_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = cur_tlv_len - ofs;
			res->data.iccid = __qmi_copy_string(get_next(i), i);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_uim_get_ck_status_request(struct qmi_msg *msg, struct qmi_dms_uim_get_ck_status_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0040);

	if (req->set.facility) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.facility, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_uim_get_ck_status_response(struct qmi_msg *msg, struct qmi_dms_uim_get_ck_status_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.ck_status = 1;
			res->data.ck_status.facility_state = *(uint8_t *) get_next(1);
			res->data.ck_status.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.ck_status.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		case 0x10:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, operation_blocking_facility, *(uint8_t *) get_next(1));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_uim_set_ck_protection_request(struct qmi_msg *msg, struct qmi_dms_uim_set_ck_protection_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0041);

	if (req->set.facility) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.facility.facility, 1);
		put_tlv_var(uint8_t, req->data.facility.facility_state, 1);
		i = strlen(req->data.facility.facility_depersonalization_control_key);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.facility.facility_depersonalization_control_key, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_uim_set_ck_protection_response(struct qmi_msg *msg, struct qmi_dms_uim_set_ck_protection_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, verify_retries_left, *(uint8_t *) get_next(1));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_uim_unblock_ck_request(struct qmi_msg *msg, struct qmi_dms_uim_unblock_ck_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0042);

	if (req->set.facility) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.facility.facility, 1);
		i = strlen(req->data.facility.facility_control_key);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.facility.facility_control_key, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_uim_unblock_ck_response(struct qmi_msg *msg, struct qmi_dms_uim_unblock_ck_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, unblock_retries_left, *(uint8_t *) get_next(1));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_uim_get_imsi_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0043);

	return 0;
}

int qmi_parse_dms_uim_get_imsi_response(struct qmi_msg *msg, struct qmi_dms_uim_get_imsi_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = cur_tlv_len - ofs;
			res->data.imsi = __qmi_copy_string(get_next(i), i);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_uim_get_state_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0044);

	return 0;
}

int qmi_parse_dms_uim_get_state_response(struct qmi_msg *msg, struct qmi_dms_uim_get_state_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, state, *(uint8_t *) get_next(1));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_band_capabilities_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0045);

	return 0;
}

int qmi_parse_dms_get_band_capabilities_response(struct qmi_msg *msg, struct qmi_dms_get_band_capabilities_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, band_capability, le64_to_cpu(*(uint64_t *) get_next(8)));
			break;

		case 0x10:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, lte_band_capability, le64_to_cpu(*(uint64_t *) get_next(8)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_factory_sku_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0046);

	return 0;
}

int qmi_parse_dms_get_factory_sku_response(struct qmi_msg *msg, struct qmi_dms_get_factory_sku_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = cur_tlv_len - ofs;
			res->data.sku = __qmi_copy_string(get_next(i), i);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_firmware_preference_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0047);

	return 0;
}

int qmi_parse_dms_get_firmware_preference_response(struct qmi_msg *msg, struct qmi_dms_get_firmware_preference_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = *(uint8_t *) get_next(1);
			res->data.list = __qmi_alloc_static(i * sizeof(res->data.list[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.list[res->data.list_n].type = *(uint8_t *) get_next(1);
				for (ii = 0; ii < 16; ii++) {
					res->data.list[res->data.list_n].unique_id[ii] = *(uint8_t *) get_next(1);
				}
				ii = *(uint8_t *) get_next(1);
				res->data.list[res->data.list_n].build_id = __qmi_copy_string(get_next(ii), ii);
				res->data.list_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_set_firmware_preference_request(struct qmi_msg *msg, struct qmi_dms_set_firmware_preference_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0048);

	if (req->data.list) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.list_n, 1);
		for (i = 0; i < req->data.list_n; i++) {
			unsigned int ii;
			put_tlv_var(uint8_t, req->data.list[i].type, 1);
			for (ii = 0; ii < 16; ii++) {
				put_tlv_var(uint8_t, req->data.list[i].unique_id[ii], 1);
			}
			ii = strlen(req->data.list[i].build_id);
			put_tlv_var(uint8_t, ii, 1);
			strncpy(__qmi_alloc_static(ii), req->data.list[i].build_id, ii);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.download_override) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.download_override, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->set.modem_storage_index) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.modem_storage_index, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_set_firmware_preference_response(struct qmi_msg *msg, struct qmi_dms_set_firmware_preference_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = *(uint8_t *) get_next(1);
			res->data.image_download_list = __qmi_alloc_static(i * sizeof(res->data.image_download_list[0]));
			while(i-- > 0) {
				res->data.image_download_list[res->data.image_download_list_n] = *(uint8_t *) get_next(1);
				res->data.image_download_list_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_list_stored_images_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0049);

	return 0;
}

int qmi_parse_dms_list_stored_images_response(struct qmi_msg *msg, struct qmi_dms_list_stored_images_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = *(uint8_t *) get_next(1);
			res->data.list = __qmi_alloc_static(i * sizeof(res->data.list[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.list[res->data.list_n].type = *(uint8_t *) get_next(1);
				res->data.list[res->data.list_n].maximum_images = *(uint8_t *) get_next(1);
				res->data.list[res->data.list_n].index_of_running_image = *(uint8_t *) get_next(1);
				ii = *(uint8_t *) get_next(1);
				res->data.list[res->data.list_n].sublist = __qmi_alloc_static(ii * sizeof(res->data.list[res->data.list_n].sublist[0]));
				while(ii-- > 0) {
					unsigned int iii;
					res->data.list[res->data.list_n].sublist[res->data.list[res->data.list_n].sublist_n].storage_index = *(uint8_t *) get_next(1);
					res->data.list[res->data.list_n].sublist[res->data.list[res->data.list_n].sublist_n].failure_count = *(uint8_t *) get_next(1);
					for (iii = 0; iii < 16; iii++) {
						res->data.list[res->data.list_n].sublist[res->data.list[res->data.list_n].sublist_n].unique_id[iii] = *(uint8_t *) get_next(1);
					}
					iii = *(uint8_t *) get_next(1);
					res->data.list[res->data.list_n].sublist[res->data.list[res->data.list_n].sublist_n].build_id = __qmi_copy_string(get_next(iii), iii);
					res->data.list[res->data.list_n].sublist_n++;
				}
				res->data.list_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_delete_stored_image_request(struct qmi_msg *msg, struct qmi_dms_delete_stored_image_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x004A);

	if (req->set.image) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.image.type, 1);
		for (i = 0; i < 16; i++) {
			put_tlv_var(uint8_t, req->data.image.unique_id[i], 1);
		}
		i = strlen(req->data.image.build_id);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.image.build_id, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_delete_stored_image_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_set_time_request(struct qmi_msg *msg, struct qmi_dms_set_time_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x004B);

	if (req->set.time_value) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint64_t, cpu_to_le64(req->data.time_value), 8);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.time_reference_type) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.time_reference_type), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_set_time_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_get_stored_image_info_request(struct qmi_msg *msg, struct qmi_dms_get_stored_image_info_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x004C);

	if (req->set.image) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.image.type, 1);
		for (i = 0; i < 16; i++) {
			put_tlv_var(uint8_t, req->data.image.unique_id[i], 1);
		}
		i = strlen(req->data.image.build_id);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.image.build_id, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_get_stored_image_info_response(struct qmi_msg *msg, struct qmi_dms_get_stored_image_info_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.boot_version = 1;
			res->data.boot_version.major_version = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.boot_version.minor_version = le16_to_cpu(*(uint16_t *) get_next(2));
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			res->set.pri_version = 1;
			res->data.pri_version.pri_version = le32_to_cpu(*(uint32_t *) get_next(4));
			i = 32;
			res->data.pri_version.pri_info = __qmi_copy_string(get_next(i), i);
			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			qmi_set(res, oem_lock_id, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_alt_net_config_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x004D);

	return 0;
}

int qmi_parse_dms_get_alt_net_config_response(struct qmi_msg *msg, struct qmi_dms_get_alt_net_config_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, config, *(uint8_t *) get_next(1));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_set_alt_net_config_request(struct qmi_msg *msg, struct qmi_dms_set_alt_net_config_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x004E);

	if (req->set.config) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.config, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_set_alt_net_config_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_get_software_version_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0051);

	return 0;
}

int qmi_parse_dms_get_software_version_response(struct qmi_msg *msg, struct qmi_dms_get_software_version_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = cur_tlv_len - ofs;
			res->data.version = __qmi_copy_string(get_next(i), i);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_set_service_programming_code_request(struct qmi_msg *msg, struct qmi_dms_set_service_programming_code_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x0052);

	if (req->data.current_code) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		i = 6;
		strncpy(__qmi_alloc_static(i), req->data.current_code, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->data.new_code) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		i = 6;
		strncpy(__qmi_alloc_static(i), req->data.new_code, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_set_service_programming_code_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_get_supported_messages_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x001E);

	return 0;
}

int qmi_parse_dms_get_supported_messages_response(struct qmi_msg *msg, struct qmi_dms_get_supported_messages_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.list = __qmi_alloc_static(i * sizeof(res->data.list[0]));
			while(i-- > 0) {
				res->data.list[res->data.list_n] = *(uint8_t *) get_next(1);
				res->data.list_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_get_usb_composition_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x555B);

	return 0;
}

int qmi_parse_dms_get_usb_composition_response(struct qmi_msg *msg, struct qmi_dms_get_usb_composition_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, composition, *(uint8_t *) get_next(1));
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			i = *(uint8_t *) get_next(1);
			res->data.supported = __qmi_alloc_static(i * sizeof(res->data.supported[0]));
			while(i-- > 0) {
				res->data.supported[res->data.supported_n] = *(uint8_t *) get_next(1);
				res->data.supported_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_dms_set_usb_composition_request(struct qmi_msg *msg, struct qmi_dms_set_usb_composition_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x555C);

	if (req->set.composition) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.composition, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_dms_set_usb_composition_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_dms_set_fcc_authentication_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_DMS);
	msg->svc.message = cpu_to_le16(0x555F);

	return 0;
}

int qmi_parse_dms_set_fcc_authentication_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

